# 《极客园移动端项目》



# 一些不实装功能的静态页面



## 底部导航栏“问答”页面

> 目标：实现问答页面的静态结构和样式



**操作步骤**

将资源包的样式拷贝到 `pages/Question/`目录下，然后在该目录下的 `index.js`中编写组件代码：

```jsx
import NavBar from '@/components/NavBar'
import styles from './index.module.scss'

const Question = () => {
  return (
    <div className={styles.root}>
      {/* 顶部导航栏 */}
      <NavBar>问答</NavBar>

      {/* 问答列表 */}
      <div className="question-list">
        <div className="question-item">
          <div className="left">
            <h3>作为 IT 行业的过来人，你有什么话想对后辈说的？</h3>
            <div className="info">
              <span>赞同 1000+</span>
              <span>评论 500+</span>
              <span>1小时前</span>
            </div>
          </div>
          <div className="right">
            <img
              src="https://pic1.zhimg.com/80/v2-8e77b2771314f674cccba5581560d333_xl.jpg?source=4e949a73"
              alt=""
            />
          </div>
        </div>
        <div className="question-item">
          <div className="left">
            <h3>作为 IT 行业的过来人，你有什么话想对后辈说的？</h3>
            <div className="info">
              <span>赞同 1000+</span>
              <span>评论 500+</span>
              <span>1小时前</span>
            </div>
          </div>
          <div className="right">
            <img
              src="https://pic1.zhimg.com/80/v2-8e77b2771314f674cccba5581560d333_xl.jpg?source=4e949a73"
              alt=""
            />
          </div>
        </div>
        <div className="question-item">
          <div className="left">
            <h3>作为 IT 行业的过来人，你有什么话想对后辈说的？</h3>
            <div className="info">
              <span>赞同 1000+</span>
              <span>评论 500+</span>
              <span>1小时前</span>
            </div>
          </div>
          <div className="right">
            <img
              src="https://pic1.zhimg.com/80/v2-8e77b2771314f674cccba5581560d333_xl.jpg?source=4e949a73"
              alt=""
            />
          </div>
        </div>
        <div className="question-item">
          <div className="left">
            <h3>作为 IT 行业的过来人，你有什么话想对后辈说的？</h3>
            <div className="info">
              <span>赞同 1000+</span>
              <span>评论 500+</span>
              <span>1小时前</span>
            </div>
          </div>
          <div className="right">
            <img
              src="https://pic1.zhimg.com/80/v2-8e77b2771314f674cccba5581560d333_xl.jpg?source=4e949a73"
              alt=""
            />
          </div>
        </div>
        <div className="question-item">
          <div className="left">
            <h3>作为 IT 行业的过来人，你有什么话想对后辈说的？</h3>
            <div className="info">
              <span>赞同 1000+</span>
              <span>评论 500+</span>
              <span>1小时前</span>
            </div>
          </div>
          <div className="right">
            <img
              src="https://pic1.zhimg.com/80/v2-8e77b2771314f674cccba5581560d333_xl.jpg?source=4e949a73"
              alt=""
            />
          </div>
        </div>
      </div>
    </div>
  )
}

export default Question
```



---



## 底部导航栏“视频”页面

> 目标：实现视频页面的静态结构和样式



**操作步骤**

将资源包的样式拷贝到 `pages/Video/`目录下，然后在该目录下的 `index.js`中编写组件代码：

```jsx
import NavBar from '@/components/NavBar'
import styles from './index.module.scss'

const Video = () => {
  return (
    <div className={styles.root}>
      {/* 顶部导航栏 */}
      <NavBar>视频</NavBar>

      {/* 视频列表 */}
      <div className="video-list">
        <div className="video-item">
          <h3 className="title">
            格力电器将继续发展手机业务，并将向全产业覆盖！
          </h3>
          <div className="play">
            <video src="https://ips.ifeng.com/video19.ifeng.com/video09/2021/05/26/p6803231351488126976-102-8-161249.mp4?reqtype=tsl&vid=2c791e3b-444e-4578-83e3-f4808228ae3b&uid=0puFR4&from=v_Free&pver=vHTML5Player_v2.0.0&sver=&se=&cat=&ptype=&platform=pc&sourceType=h5&dt=1622096387396&gid=6a4poXmsep1E&sign=39f76885daca6503ebf90acbfffc1ff1&tm=1622096387396"></video>
          </div>
          <span>1563次播放</span>
        </div>

        <div className="video-item">
          <h3 className="title">
            你用上5G了吗？我国5G手机终端达3.1亿 占全球比例超80％
          </h3>
          <div className="play">
            <video src="https://ips.ifeng.com/video19.ifeng.com/video09/2021/05/26/p6803268684325330944-102-8-184104.mp4?reqtype=tsl&vid=ec74b1e4-d1fa-488b-aaf5-71984ca7d13e&uid=1Vun5L&from=v_Free&pver=vHTML5Player_v2.0.0&sver=&se=&cat=&ptype=&platform=pc&sourceType=h5&dt=1622096310639&gid=fg3vsXmseXFv&sign=38e7c790561e1fd1b57e61a1cbd8031c&tm=1622096310639"></video>
          </div>
          <span>1563次播放</span>
        </div>
      </div>
    </div>
  )
}

export default Video
```



---



## 个人中心“用户反馈”页面

> 目标：实现用户反馈页面的静态结构和样式



**操作步骤**

将资源包的样式拷贝到 `pages/Profile/Feedback/`目录下，然后在该目录下的 `index.js`中编写组件代码：

```jsx
import NavBar from '@/components/NavBar'
import { ImagePicker, InputItem } from 'antd-mobile'
import { useHistory } from 'react-router-dom'
import styles from './index.module.scss'

const ProfileFeedback = () => {
  const history = useHistory()

  return (
    <div className={styles.root}>
      <NavBar onLeftClick={() => history.go(-1)}>意见反馈</NavBar>

      <div className="wrapper">
        <div className="feedback-item">
          <p className="title">简介</p>
          <div className="textarea-wrap">
            <textarea className="textarea" placeholder="请输入"></textarea>
            <div className="count">0/100</div>
          </div>
          <ImagePicker files={[]} multiple />
          <p className="image-picker-desc">最多6张，单个图片不超过20M。</p>
        </div>

        <div className="feedback-item">
          <p className="title">联系方式</p>
          <InputItem placeholder="请输入手机号码便于联系（非必填）" />
        </div>

        <div className="feedback-item feedback-submit">
          <button>提交反馈</button>
        </div>
      </div>
    </div>
  )
}

export default ProfileFeedback
```



---



# 首页功能



## 封装顶部频道 Tab 栏组件：基本功能

> 目标：将 Tab 形式的文章频道展示区域封装成一个组件



<img src="极客园移动端2.assets/image-20210904104516844.png" alt="image-20210904104516844" style="zoom:35%;" />



实现思路：

- 组件中有两个区域：上面的 tab 区域和下面的内容区域
- 选项按钮区域和内容区域的数据由组件属性传入
- 可传入初始选中 tab 的索引
- tab 切换时可触发回调函数



**操作步骤**

1. 创建 `components/Tabs/`目录，复制资源包中对应的样式文件到该目录下，然后创建 `index.js`并编写组件的基本结构

```jsx
import PropTypes from 'prop-types'
import React from 'react'
import styles from './index.module.scss'

/**
 * Tab 容器组件
 * @param {Array} props.tabs 所有 Tab 选项按钮的配置数据
 * @param {Array} props.children 所有 Tab 选项按钮对应的内容数据
 * @param {Number} props.index 当前选中 Tab 的索引
 * @param {Function} props.onChange 切换 Tab 选项按钮时的回调函数
 */
const Tabs = ({ index = 0, tabs = [], children, onChange }) => {
  return (
    <div className={styles.root}>
      <div className="tabs">

        {/* tab 选项按钮容器 */}
        <div className="tabs-wrap">
          <div className="tabs-nav">
            {/* tab 选项按钮 */}
            <div className="tab active">
              <span>tab1</span>
            </div>
            <div className="tab">
              <span>tab2</span>
            </div>
            <div className="tab">
              <span>tab3</span>
            </div>
            <div className="tab">
              <span>tab4</span>
            </div>
            <div className="tab">
              <span>tab5</span>
            </div>

            {/* tab 底下的指示短线条 */}
            <div className="tab-line"></div>
          </div>
        </div>

        {/* tab 下面的主内容区域 */}
        <div className="tabs-content">
        </div>

      </div>
    </div>
  )
}

Tabs.propTypes = {
  // tabs 属性必传
  tabs: PropTypes.array.isRequired,

  //children 属性值必须是界面元素
  children: PropTypes.arrayOf(PropTypes.element)
}

export default Tabs
```



2. 使用通过属性传入的 `tabs` 数据，渲染选项卡按钮：

`tabs` 属性值的格式为下列形式的数组：

```json
[
  { "id": 1, "name": "频道1" },
  { "id": 2, "name": "频道2" },
  // ...
]
```

渲染代码：

```jsx
{/* tab 选项卡容器 */}
<div className="tabs-wrap">
  <div className="tabs-nav">
    {/* tab 选项卡 */}
    {tabs.map((item, i) => (
      <div key={i} className="tab">
        <span>{item.name}</span>
      </div>
    ))}

    {/* tab 底下的指示短线条 */}
    <div className="tab-line"></div>
  </div>
</div>
```



3. 实现点击选项卡按钮，能进行按钮间的切换，并调用 `onChange`回调函数

```jsx
import classnames from 'classnames'
import PropTypes from 'prop-types'
import React, { useEffect, useRef, useState } from 'react'
import styles from './index.module.scss'
```

```jsx
// 当前选中的选项卡按钮的索引
const [activeIndex, setActiveIndex] = useState(index)

// 让组件属性 index 的值变化时，设置 activeIndex 状态
useEffect(() => {
  setActiveIndex(index)
}, [index])
```

```jsx
{/* tab 选项卡 */}
{tabs.map((item, i) => (
  <div
    key={i}
    className={classnames('tab', i === activeIndex ? 'active' : '')}
    onClick={() => {
      setActiveIndex(i)
      onChange(i)
    }}
    >
    <span>{item.name}</span>
  </div>
))}
```



---



## 封装顶部频道 Tab 栏组件：选中动效

>  目标：为代表选中按钮下的短线条添加动画效果



<img src="极客园移动端2.assets/image-20210904154431664.png" alt="image-20210904154431664" style="zoom:40%;" />



**操作步骤**

1. 为要操作的元素添加 ref 引用

```jsx
// 选项容器的 ref 引用
const navRef = useRef()
// 短线条的 ref 引用
const lineRef = useRef()
```

```jsx
<div className="tabs-nav" ref={navRef}> ... </div>
<div className="tab-line" ref={lineRef}></div>
```



2. 编写动效逻辑：

```jsx
useEffect(() => {
  // Tab 栏容器
  const navEl = navRef.current

  // Tab 栏容器的宽度
  const navWidth = navEl.offsetWidth || 289

  // 当前选项卡按钮
  const activeTab = navEl.children[activeIndex]

  // 当前选项卡按钮的宽度
  const activeTabWidth = activeTab.offsetWidth || 60

  // 当前选项卡按钮的左侧位置
  // 注意：第一次获取 offsetLeft 值为 0，以后每次获取为 8
  // 所以设置默认值为 8，让所有情况下的 offsetLeft 都相同
  const activeTabOffsetLeft = activeTab.offsetLeft || 8

  // 滚动效果的起始位置：即 Tab 栏容器的左侧位置
  const from = navEl.scrollLeft

  // 滚动效果的结束位置
  const to = activeTabOffsetLeft - (navWidth - activeTabWidth) / 2

  // 滚动效果执行帧率
  const frames = Math.round(200 / 24)

  let count = 0
  function animate() {
    navEl.scrollLeft += (to - from) / frames
    count++
    if (count < frames) {
      requestAnimationFrame(animate)
    }
  }
  animate()

  // window.innerWidth / 375：手动处理 JS 移动端适配
  // 15 表示短线条宽度的一半
  const translateX = activeTabOffsetLeft + activeTabWidth / 2 - 15 * (window.innerWidth / 375)
  lineRef.current.style.transform = `translateX(${translateX}px)`
}, [
  // 注意：由于 tabs 是动态数据，为了能在 tabs 数据加载完后获取到选项卡按钮元素，
  // 因此这里要将 tabs 作为依赖项。否则会导致 navRef.current.children[activeIndex] 
  // 拿到的是短线条元素，而不是第一个选项卡按钮元素
  activeIndex,
  tabs
])
```



---



## 封装顶部频道 Tab 栏组件：内容切换

>  目标：实现切换选项卡按钮时，也切换相应的内容



**操作步骤**

1. 将通过组件 children 传入的子元素，放到 tab 主内容区域：

```jsx
{/* tab 下面的主内容区域 */}
<div className="tabs-content">
  {React.Children.map(children, (child, index) => {
    return (
      // 为每个子元素包裹一个 div，用来控制显示或隐藏
      <div
        className="tabs-content-wrap"
        style={{ display: index === activeIndex ? 'block' : 'none' }}
        >
        {
          // 为每个子元素生成副本，并传入选中选项卡的 id 值
          React.cloneElement(child, { aid: tabs[activeIndex]?.id || 0 })
        }
      </div>
    )
  })}
</div>
```



> 测试以上 Tabs 组件的完整代码：

```jsx

import Tabs from "@/components/Tabs"
import { useState } from "react"
import styles from './index.module.scss'

const TestTabContent = ({ label, aid }) => {
  return <div>{label}-{aid}</div>
}

const Home = () => {
  const tabs = [
    { "id": 1, "name": "频道1" },
    { "id": 2, "name": "频道2" },
    { "id": 3, "name": "频道3" },
    { "id": 4, "name": "频道4" },
    { "id": 5, "name": "频道5" },
    { "id": 6, "name": "频道6" },
    { "id": 7, "name": "频道7" },
    { "id": 8, "name": "频道8" },
    { "id": 9, "name": "频道9" },
    { "id": 10, "name": "频道10" },
  ]

  const [tabActiveIndex, setTabActiveIndex] = useState(0)

  return (
    <div className={styles.root}>
      <Tabs
        tabs={tabs}
        index={tabActiveIndex}
        onChange={i => setTabActiveIndex(i)}
      >
        {tabs.map(item => {
          return <TestTabContent key={item.id} label={item.name} />
        })}
      </Tabs>
    </div>
  )
}

export default Home
```



---



## 请求频道数据

> 目标：调用后端接口获取用户的频道数据，然后存入 Redux 和 LocalStorage 中



实现思路：

- 实现请求后端接口，获取频道数据的 Action Creator 函数
- 实现将频道数据存入 Redux 中的 Reducer 函数
- 在进入页面时，调用 Action



**操作步骤**

1. 创建 `store/reducers/home.js`，编写存储频道数据的 Reducer 逻辑：

```jsx
// 初始状态
const initialState = {
  userChannels: []
}

export const home = (state = initialState, action) => {
  const { type, payload } = action

  switch (type) {
    case 'home/channel':
      return {
        ...state,
        userChannels: payload
      }

    default:
      return state
  }
}
```



2. 在`store/reducer/index.js`中，配置以上新建的 Reducer 模块：

```jsx
import { home } from './home'

const rootReducer = combineReducers({
  // ...
  home
})
```



3. 在 `utils/storage.js`中，添加操作本地缓存中的频道数据的工具函数：

```js
// 用户频道的本地缓存键名
const CHANNEL_KEY = 'itcast_channel_k'

/**
 * 从缓存获取频道
 */
export const getLocalChannels = () => {
  return JSON.parse(localStorage.getItem(CHANNEL_KEY)) || []
}

/**
 * 将频道数据存入本地缓存
 * @param {Array} channels 
 */
export const setLocalChannels = channels => {
  localStorage.setItem(CHANNEL_KEY, JSON.stringify(channels))
}

/**
 * 删除本地缓存中的频道数据
 */
export const removeLocalChannels = () => {
  localStorage.removeItem(CHANNEL_KEY)
}
```



4. 创建 `store/actions/home.js`，编写请求频道数据的 Action Creator：

```jsx
import http from '@/utils/http'
import { setLocalChannels } from '@/utils/storage'

/**
 * 将用户频道保存到 Redux
 * @param {Array} channels 
 * @returns 
 */
export const setUserChannels = channels => {
  return {
    type: 'home/channel',
    payload: channels
  }
}

/**
 * 获取频道
 * @returns thunk
 */
export const getUserChannels = () => {
  return async dispatch => {
    // 请求数据
    const res = await http.get('/user/channels')
    const { channels } = res.data.data

    // 将频道数据保存到 Redux
    dispatch(setUserChannels(channels))

    // 将频道数据保存到 LocalStorage
    setLocalChannels(channels)
  }
}
```



5. 在 `pages/Home/index.js` 中，通过 `useEffect`在进入首页时调用以上 Action：

```jsx
import { getUserChannels } from '@/store/actions/home'
import { useEffect } from 'react'
import { useDispatch } from 'react-redux'
import styles from './index.module.scss'

const Home = () => {
  const dispatch = useDispatch()

  useEffect(() => {
    dispatch(getUserChannels())
  }, [dispatch])

  return (
    <div className={styles.root}>
    </div>
  )
}

export default Home
```



从后端获取到的数据：

<img src="极客园移动端2.assets/image-20210904174824811.png" alt="image-20210904174824811" style="zoom:40%;" />



---



## 频道数据的获取逻辑优化

> 目标：根据用户是否登录，以及本地缓存是否有频道数据，来优化频道数据的存取逻辑



实现思路：

- 如果用户未登录，则先尝试从本地缓存中读取频道，如缓存中有就把缓存中的数据再放到 Redux 中；如缓存中没有，就从服务端读取
- 如果用户已登录，则每次都从服务端读取最新的频道数据



**操作步骤**

1. 改造首页的 `useEffect` 代码段中的逻辑：

```jsx
useEffect(() => {
  const loadChannel = async () => {
    // 如果用户未登录，则尝试从本地缓存中获取频道数据
    if (!hasToken()) {
      const localChannels = getLocalChannels()
      if (localChannels.length > 0) {
        return dispatch(setUserChannels(localChannels))
      }
    }

    // 如果用户已登录，或未登录但缓存中也没有，则从后端获取频道数据
    dispatch(getUserChannels())
  }

  loadChannel()
}, [dispatch])
```



---



## 展示频道 Tab 栏

> 目标：从 Redux 中获取已经获取的频道数据，用来在首页中渲染生成 Tabs 组件



<img src="极客园移动端2.assets/image-20210906082651272.png" alt="image-20210906082651272" style="zoom:50%;" />



实现思路：

- 从 Redux 中获取频道数据
- 在界面上调用 Tabs 组件



**操作步骤**

1. 在首页代码中，获取 Redux 中存储的频道数据

```jsx
import { useDispatch, useSelector } from 'react-redux'
```

```jsx
// 频道数据
const channels = useSelector(state => state.home.userChannels)
```



2. 调用 Tabs 组件

```jsx
import { useEffect, useState } from 'react'
```

```jsx
// 当前选中的 Tab 选项卡按钮索引
const [tabActiveIndex, setTabActiveIndex] = useState(0)
```

```jsx
<div className={styles.root}>
  {/* 频道 Tab 栏 */}
  <Tabs
    index={tabActiveIndex}
    tabs={channels}
    onChange={i => setTabActiveIndex(i)}
    >
    {/* 频道 Tab 对应的内容 */}
  </Tabs>

  {/* 频道 Tab 栏右侧的两个图标按钮：搜索、频道管理 */}
  <div className="tabs-opration">
    <Icon type="iconbtn_search" />
    <Icon type="iconbtn_channel" />
  </div>
</div>
```



---



## 频道管理组件：静态结构

> 目标：实现一个频道选择器，让用户可自定义想要查看的频道



<img src="极客园移动端2.assets/image-20210906084900570.png" alt="image-20210906084900570" style="zoom:40%;" />



实现思路：

- 频道管理的界面单独封装成一个组件
- 使用抽屉组件 Drawer 弹出以上频道管理界面



**操作步骤**

1. 创建 `pages/Home/components/Channels/`目录，并拷贝资源包中的样式文件到该目录下，然后再新建一个 `index.js`，编写频道管理组件的静态界面代码：

```jsx
import Icon from '@/components/Icon'
import styles from './index.module.scss'

/**
 * 频道管理组件
 * @param {Number} props.tabActiveIndex 用户选中的频道的索引
 * @param {Function} props.onClose 关闭频道管理抽屉时的回调函数
 * @param {Function} props.onChannelClick 当点击频道列表中的某个频道时的会带哦函数
 */
const Channels = ({ tabActiveIndex, onClose, onChannelClick }) => {

  return (
    <div className={styles.root}>
      {/* 顶部栏：带关闭按钮 */}
      <div className="channel-header">
        <Icon type="iconbtn_channel_close" onClick={onClose} />
      </div>

      {/* 频道列表 */}
      <div className="channel-content">
        {/* 当前已选择的频道列表 */}
        <div className="channel-item edit">
          <div className="channel-item-header">
            <span className="channel-item-title">我的频道</span>
            <span className="channel-item-title-extra">
              点击删除频道
            </span>
            <span className="channel-item-edit">
              保存
            </span>
          </div>

          <div className="channel-list">
            <span className="channel-list-item">
              频道1
              <Icon type="iconbtn_tag_close" />
            </span>
            <span className="channel-list-item">
              频道2
              <Icon type="iconbtn_tag_close" />
            </span>
          </div>
        </div>

        {/* 推荐的频道列表 */}
        <div className="channel-item">
          <div className="channel-item-header">
            <span className="channel-item-title">频道推荐</span>
            <span className="channel-item-title-extra">点击添加频道</span>
          </div>
          <div className="channel-list">
            <span className="channel-list-item">
              + 推荐1
            </span>
            <span className="channel-list-item">
              + 推荐2
            </span>
          </div>
        </div>
      </div>
    </div>
  )
}

export default Channels
```



2. 在首页代码中，使用抽屉组件 Drawer 来展示频道管理组件：

```jsx
import { Drawer } from 'antd-mobile'
```

```jsx
// 控制频道管理抽屉的显示和隐藏
const [drawerVisible, setDrawerVisible] = useState(false)
```

```jsx
{/* 频道管理抽屉 */}
<Drawer
  className="my-drawer"
  style={{ minHeight: document.documentElement.clientHeight }}
  children={''}
  sidebar={
    <Channels
      tabActiveIndex={tabActiveIndex}
      onClose={() => setDrawerVisible(false)}
      onChannelClick={() => {}}
      />
  }
  open={drawerVisible}
  onOpenChange={() => setDrawerVisible(false)}
  />
```



---



## 频道管理组件：请求推荐频道的数据

> 目标：在进入频道管理界面时，发送请求获取推荐频道的数据



实现思路：

- 编写 Action Creator 来发送请求
- 编写 Reducer 将请求到的数据存入 Redux 中
- 使用 `useEffect` 在组件创建时调用 Action



**操作步骤**

1. 在`store/reducers/home.js`中，添加设置推荐频道数据的 Reducer 逻辑：

```js
// 初始状态
const initialState = {
	// ...
  recommendChannels: [],
}

export const home = (state = initialState, action) => {
  const { type, payload } = action

  switch (type) {
    case 'home/recommend':
      return {
        ...state,
        recommendChannels: payload
      }
      
    // ...
  }
}
```



2. 安装 `lodash` 工具库

```bash
npm i lodash --save
```



3. 在`store/reducers/home.js`中，编写请求频道数据相关的 Action Creator：

```js
import differenceBy from 'lodash/differenceBy'
```

```jsx
/**
 * 将推荐频道保存到 Redux
 * @param {Array} channels 
 * @returns 
 */
export const setRecommendChannels = channels => {
  return {
    type: 'home/recommend',
    payload: channels
  }
}

/**
 * 获取所有频道中排除用户自己的频道数据
 * @returns thunk
 */
export const getRecommendChannels = () => {
  return async (dispatch, getState) => {
    // 请求所有的推荐频道
    const res = await http.get('/channels')
    const { channels } = res.data.data

    // 去掉已被用户选中的频道
    const { userChannels } = getState().home
    const recommendChannels = differenceBy(channels, userChannels, 'id')

    // 保存到 Redux
    dispatch(setRecommendChannels(recommendChannels))
  }
}
```



4. 在频道管理组件中调用以上的 Action：

```jsx
import { useEffect } from 'react'
import { useDispatch } from 'react-redux'
import { getRecommendChannels } from '@/store/actions/home'
```

```jsx
const dispatch = useDispatch()

useEffect(() => {
  dispatch(getRecommendChannels())
}, [dispatch, userChannels])
```



---



## 频道管理组件：渲染频道列表

> 目标：渲染 ”我的频道“ 和 ”推荐频道“ 两个列表内容



实现思路：

- ”我的频道“ 的数据来源于通过组件属性传入的 `userChannels`
- ”推荐频道“ 的数据来源于之前调用后端接口并存入 Redux 中的 `recommendChannels`



**操作步骤**

1. 从 Redux 中获取推荐频道的数据

```jsx
import classnames from 'classnames'
import { useDispatch, useSelector } from 'react-redux'
```

```jsx
// 推荐频道数据
const recommendChannels = useSelector(state => state.home.recommendChannels)
```

```jsx
{/* 我的频道列表 */}
<div className="channel-list">
  {userChannels.map((item, index) => (
    <span
      key={item.id}
      className={classnames('channel-list-item', index === tabActiveIndex ? 'selected' : '')}
      >
      {item.name}
      <Icon type="iconbtn_tag_close" />
    </span>
  ))}
</div>
```

```jsx
{/* 推荐的频道列表 */}
<div className="channel-list">
  {recommendChannels.map(item => (
    <span
      key={item.id}
      className="channel-list-item"
      >
      + {item.name}
    </span>
  ))}
</div>
```



---



## 频道管理组件：切换普通/编辑模式

> 目标：点击界面上的 ”编辑“、”保存“ 按钮，进行普通模式和编辑模式之间的相互切换



<img src="极客园移动端2.assets/image-20210906151656929.png" alt="image-20210906151656929" style="zoom:40%;" />

<img src="极客园移动端2.assets/image-20210906151724523.png" alt="image-20210906151724523" style="zoom:40%;" />

实现思路：

- 通过一个 Boolean 类型的状态，控制这两种模式



**操作步骤**

1. 声明布尔类型的状态

```jsx
import { useEffect, useState } from 'react'
```

```jsx
// 控制普通/编辑模式的状态
const [editable, setEditable] = useState(false)
```



2. 为 ”保存“/”编辑“ 按钮添加点击事件来切换 `editable` 状态，并使用该状态控制相关样式和文字：

```jsx
<div className={classnames('channel-item', editable ? 'edit' : '')}>
  <div className="channel-item-header">
    <span className="channel-item-title">我的频道</span>
    <span className="channel-item-title-extra">
      {editable ? '点击删除频道' : '点击进入频道'}
    </span>
    <span className="channel-item-edit" onClick={() => setEditable(!editable)}>
      {editable ? '保存' : '编辑'}
    </span>
  </div>
  
  {/* ... */}
</div>
```



---



## 频道管理组件：添加”我的频道“

> 目标：实现点击一个推荐频道，将它加入到我的频道列表中



<img src="极客园移动端2.assets/image-20210906155726961.png" alt="image-20210906155726961" style="zoom:40%;" />



实现思路：

- 通过 Redux Action 将点击的频道保存到服务端、及 Redux 中
- 点击推荐频道中的 ”标签“ 时调用以上的 Action



**操作步骤**

1. 在 `store/actions/home.js`中，实现 Action Creator：

```js
/**
 * 添加频道
 * @param {Object} channel 要添加的频道数据
 * @returns thunk
 */
export const addChannel = channel => {
  return async (dispatch, getState) => {
    // 只有登录用户可以将添加的推荐频道保存到服务器
    if (hasToken()) {
      await http.patch('/user/channels', {
        channels: [channel]
      })
    }

    // 获取 Redux 中的状态
    const { userChannels, recommendChannels } = getState().home

    // 将最新的”我的频道“保存到 Redux 及 LocalStorage 中
    const newUserChannels = [...userChannels, channel]
    dispatch(setUserChannels(newUserChannels))
    setLocalChannels(newUserChannels)

    // 从推荐频道中剔除当前添加的频道，再保存到 Redux 中
    const newRecommendChannels = recommendChannels.filter(item => item.id !== channel.id)
    dispatch(setRecommendChannels(newRecommendChannels))
  }
}
```



2. 为推荐频道”标签“添加点击事件

```jsx
import { addChannel, getRecommendChannels } from '@/store/actions/home'
```

```jsx
const onAddChannel = channel => {
  // 调用 Action 来添加频道
  dispatch(addChannel(channel))
}
```

```jsx
<span
  key={item.id}
  className="channel-list-item"
  onClick={() => onAddChannel(item)}
  >
  + {item.name}
</span>
```



---



## 频道管理组件：删除”我的频道“

> 目标：在编辑模式下，点击”我的频道“内的删除按钮来移除频道，且被移除的频道会回到推荐频道中	



<img src="极客园移动端2.assets/image-20210906173003541.png" alt="image-20210906173003541" style="zoom:40%;" />



实现思路：

- 通过 Redux Action 来操作 Redux 中的以及后端存放的 ”我的频道“ 和 ”推荐频道“，实现删除功能



**操作步骤**

1. 在 `store/actions/home.js`中，实现 Action Creator：

```jsx
/**
 * 删除频道
 * @param {Object} channel 要删除的频道数据
 * @returns thunk
 */
export const removeChannel = channel => {
  return async (dispatch, getState) => {
    if (hasToken()) {
      await http.delete(`/user/channels/${channel.id}`)
    }

    // 获取 Redux 中的状态
    const { userChannels, recommendChannels } = getState().home

    // 从 Redux 及 LocalStorage 中移除频道
    const newUserChannels = userChannels.filter(item => item.id !== channel.id)
    dispatch(setUserChannels(newUserChannels))
    setLocalChannels(newUserChannels)

    // 将被移除的频道放回到推荐频道中，并保存到 Redux
    const newRecommendChannels = [...recommendChannels, channel].sort((a, b) => {
      return a.id - b.id
    })
    dispatch(setRecommendChannels(newRecommendChannels))
  }
}
```



2. 在删除按钮上添加点击事件，并在监听函数中调用 Action：

```jsx
import { addChannel, getRecommendChannels, removeChannel } from '@/store/actions/home'
```

```jsx
const onDeleteChannel = async channel => {
  // 调用 Action 来删除频道
  dispatch(removeChannel(channel))
}
```

```jsx
<Icon type="iconbtn_tag_close" onClick={() => onDeleteChannel(item)} />
```



---



## 频道管理组件：点击”我的频道“后跳到该频道

> 目标：实现点击频道管理中的”我的频道“下的任意频道标签，可以跳转到首页中对应的 Tab 栏



在我的频道中点击：

<img src="极客园移动端2.assets/image-20210906175225627.png" alt="image-20210906175225627" style="zoom:40%;" />

在首页中切换到对应 Tab：

<img src="极客园移动端2.assets/image-20210906175246635.png" alt="image-20210906175246635" style="zoom:40%;" />



实现思路：

- 将频道管理组件中当前点击频道的 index 索引，传给父组件（即首页），让父组件去设置 Tabs 组件的当前选中索引



**操作步骤**

1. 在”我的频道“里的频道元素上添加点击事件：

```jsx
<span
  key={item.id}
  className={classnames(
    'channel-list-item',
    index === tabActiveIndex ? 'selected' : ''
  )}
  onClick={() => onChannelItemClick(index)}
  >
```

```jsx
  // 点击切换频道
  const onChannelItemClick = index => {
    // 恢复成非编辑模式
    setEditable(false)

    // 调用关闭抽屉的回调函数
    onClose()

    // 调用点击频道的回调函数
    onChannelClick(index)
  }
```



2. 在首页中，设置抽屉中的 `Channels` 组件的 `onChannelClick` 属性：

```jsx
<Channels
  // ...
  onChannelClick={i => setTabActiveIndex(i)}
  />
```



---



## 文章展示：为每个频道展示对应文章列表

> 目标：当用户点击顶部 Tab 栏中的频道后，Tab 栏下方显示文章列表



我们的做法是：在 Tab 栏下方放置和频道数量相等的 `ArticleList` 组件（该组件是我们要封装的自定义组件，用来显示实际的文章列表），当切换 Tab 栏中的频道时，所有的 `ArticleList` 会根据当前选中的频道进行显示或隐藏。



 <img src="极客园移动端2.assets/image-20210907092430720.png" alt="image-20210907092430720" style="zoom:40%;" />



**操作步骤**

1. 创建`pages/Home/components/ArticleList/`目录，将资源包中的样式文件拷贝到该目录下，然后创建 `index.js`，编写 `ArticleList`组件的基本结构代码：

```jsx
import styles from './index.module.scss'

/**
 * 文章列表组件
 * @param {String} props.channelId 当前文章列表所对应的频道ID
 * @param {String} props.aid 当前 Tab 栏选中的频道ID
 */
const ArticleList = ({ channelId, aid }) => {
  return (
    <div className={styles.root}>
      频道：{channelId} | {aid}
    </div>
  )
}

export default ArticleList
```



2. 在首页的 Tab 栏代码内调用 `ArticleList` 组件，生成与频道数量相等的文章列表：

```jsx
<Tabs
  // ...
  >
  {/* 频道 Tab 对应的内容 */}
  {channels.map(ch => <ArticleList key={ch.id} channelId={ch.id} />)}
</Tabs>
```



至此，当我们切换 Tab 栏频道时，下方可显示出对应的文章列表内容区域了。



---



## 文章展示：请求文章列表数据

> 目标：在 `ArticleList` 组件中，请求该组件对应频道的文章列表数据



**操作步骤**

1. 在 `ArticleList`组件代码中，声明存放文章列表数据的状态：

```jsx
import { useCallback, useEffect, useState } from 'react'
```

```jsx
// 存放文章列表数据
const [articles, setArticles] = useState({
  items: [],
  preTimestamp: Date.now()
})
```



2. 在 `ArticleList`组件代码中，声明一个调用文章列表后端接口的函数：

> 【接口说明】
>
> - 该接口的2个参数：频道ID、时间戳
>
> - 该接口的返回值：results、pre_timestamp
>
> 该时间戳参数如果传入的是当前最新的时间戳，则返回的是最新一页的文章数据；
>
> 如果传入的是上一次请求返回的时间戳 `pre_timestamp`，则返回的是按时间回溯的前一页文章数据。

```jsx
// 请求文章列表的函数（使用 useCallback 进行缓存）
const loadArticleListData = useCallback(async (channelId, timestamp) => {
  const res = await http.get('/articles', {
    params: {
      channel_id: channelId,
      timestamp: timestamp
    }
  })
  return res.data.data
}, [])
```



3. 在 `useEffect` 中调用以上的函数，获取第一页的文章列表数据

```jsx
useEffect(() => {
  // 加载最初的文章数据
  const loadInitialData = async () => {
    const { results, pre_timestamp } = await loadArticleListData(channelId, Date.now())
    setArticles({
      items: results,
      preTimestamp: pre_timestamp
    })
  }
  // 注意：仅当该频道被第一次选中时，才发送请求获取数据
  if (channelId === aid && articles.items.length === 0) {
    loadInitialData()
  }
}, [channelId, aid, articles.items.length, loadArticleListData])
```



---



## 文章展示：渲染文章列表

> 目标：封装文章列表的一行，成为一个单独组件，然后用之前请求到的数据渲染成一个文章列表



<img src="极客园移动端2.assets/image-20210907113815406.png" alt="image-20210907113815406" style="zoom:40%;" />



**操作步骤**

1. 安装 `dayjs`，用于格式化界面上的日期

```bash
npm i dayjs --save
```



2. 编写文章列表项组件：创建 `components/ArticleItem/`目录（因为该组件的可复用度较高，所以放在公共组件目录下比较合适），然后将资源包中的对应样式文件拷贝到该目录，并创建 `index.js`

```jsx
import Icon from '@/components/Icon'
import classnames from 'classnames'
import dayjs from 'dayjs'
import 'dayjs/locale/zh-cn'
import relativeTime from 'dayjs/plugin/relativeTime'
import styles from './index.module.scss'

dayjs.locale('zh-cn')
dayjs.extend(relativeTime)

/**
 * 文章列表项组件
 * @param {String} articleId 文章ID
 * @param {Number} coverType 封面类型：0-无图|1-单图|3-三图
 * @param {Array} coverImages 封面图片
 * @param {String} title 标题
 * @param {String} authorName 作者
 * @param {Number} commentCount 回复数
 * @param {String} publishDate 发布日期
 */
const ArticleItem = ({
  articleId,
  coverType,
  coverImages,
  title,
  authorName,
  commentCount,
  publishDate,
}) => {
  return (
    <div className={styles.root}>
      <div className={classnames(
        'article-content',
        coverType === 0 ? 'none-mt' : '',
        coverType === 3 ? 't3' : ''
      )}
      >
        {/* 标题 */}
        <h3>{title}</h3>

        {/* 封面图 */}
        {coverType !== 0 && (
          <div className="article-imgs">
            {coverImages.map((image, i) => {
              return (
                <div className="article-img-wrapper" key={i}>
                  <img src={image} alt="" />
                </div>
              )
            })}
          </div>
        )}
      </div>

      {/* 底部信息栏 */}
      <div className={classnames('article-info', coverType === 0 ? 'none-mt' : '')}>
        <span>{authorName}</span>
        <span>{commentCount} 评论</span>
        <span>{dayjs().from(publishDate)}</span>
        <span className="close">
          <Icon type="iconbtn_essay_close" />
        </span>
      </div>
    </div>
  )
}

export default ArticleItem
```



3. 在 `ArticleList` 组件中，使用之前请求到的数据，调用 `ArticleItem` 组件进行文章列表的渲染：

```jsx
<div className={styles.root}>
  <div className="articles">
    {articles.items.map(article => {
      return (
        <div className="article-item" key={article.art_id}>
          < ArticleItem
            articleId={article.art_id}
            coverType={article.cover.type}
            coverImages={article.cover.images}
            title={article.title}
            authorName={article.aut_name}
            commentCount={article.comm_count}
            publishDate={article.pubdate}
            />
        </div>
      )
    })}
  </div>
</div>
```



---



## 文章展示：封面图片的懒加载

> 目标：封装一个拥有懒加载功能的图片组件，实现对文章列表项上的封面图片进行懒加载



当前问题：文章列表一旦开始渲染，上面所有的封面图都会一次性加载，可能会浪费网络资源和降低用户体验。

解决方案：只有当用户滚动页面，真正浏览到这些列表项，才开始加载封面图片。



实现思路：

- 利用浏览器提供的 `IntersectionObserver`，监听图片元素是否进入可视区域，进入后才真正去设置图片元素的 `src` 属性进行图片加载



**操作步骤**

1. 创建`components/Image/`目录，将资源包中的对应样式文件拷贝进来，然后新建 `index.js`编写组件的基本界面代码：

```jsx
import classnames from 'classnames'
import { useEffect, useRef, useState } from 'react'
import Icon from '../Icon'
import styles from './index.module.scss'

/**
 * 拥有懒加载特性的图片组件
 * @param {String} props.src 图片地址
 * @param {String} props.className 样式类
 */
const Image = ({ src, className }) => {
  // 记录图片加载是否出错的状态
  const [isError, setIsError] = useState(false)

  // 记录图片是否正在加载的状态
  const [isLoading, setIsLoading] = useState(true)

  // 对图片元素的引用
  const imgRef = useRef(null)

  return (
    <div className={classnames(styles.root, className)}>
      {/* 正在加载时显示的内容 */}
      {isLoading && (
        <div className="image-icon">
          <Icon type="iconphoto" />
        </div>
      )}

      {/* 加载出错时显示的内容 */}
      {isError && (
        <div className="image-icon">
          <Icon type="iconphoto-fail" />
        </div>
      )}

      {/* 加载成功时显示的内容 */}
      {!isError && (
        <img alt=""
          data-src={src}
          ref={imgRef}
          onLoad={() => setIsLoading(false)}
          onError={() => setIsError(true)}
        />
      )}
    </div>
  )
}

export default Image

```



2. 使用 `useEffect` 在组件创建时和销毁时，监听图片元素一旦进入可视区域，就设置它的 `src` 属性进行加载：

```jsx
// 在组件创建时
useEffect(() => {
  // 新建一个浏览器 IntersectionObserver 对象
  // 用来监听 img 图片元素是否和视口交叉（即出现在可视区域）
  const observer = new IntersectionObserver((entries, imgObserver) => {
    entries.forEach(entry => {
      // 如果出现在可视区域，则将存放在 img 标签 data-src 属性中的图片地址，
      // 设置到 src 属性上，即开始真正加载图片
      if (entry.isIntersecting) {
        const img = entry.target
        img.src = img.dataset.src
      }
    })
  })

  // 开始监听
  observer.observe(imgRef.current)
}, [])
```



3. 在组件销毁时，停止监听

```jsx
useEffect(() => {
  // ...

  // 组件销毁时
  return () => {
    // 停止 IntersectionObserver 对象的监听
    observer.disconnect()
  }
}, [])

```



在浏览器调试工具中，可通过 `Network` 查看与确认懒加载效果：

<img src="极客园移动端2.assets/image-20210907152032939.png" alt="image-20210907152032939" style="zoom:40%;" />



---



## 文章展示：反馈菜单

> 目标：封装一个弹出菜单，让登录用户可以对自己不喜欢的文章进行举报反馈



<img src="极客园移动端2.assets/image-20210907153623469.png" alt="image-20210907153623469" style="zoom:40%;" />

<img src="极客园移动端2.assets/image-20210907153647600.png" alt="image-20210907153647600" style="zoom:40%;" />



实现思路：

由于每一个频道中都需要这样一个弹出菜单，因此，我们可以全局只生成一个该弹出菜单的组件实例，然后通过 Redux 中的共享状态去控制它的显示隐藏及要传递的数据。



**操作步骤**

1. 创建 `pages/Home/components/FeedbackActionMenu`目录，将资源包中的样式文件拷贝到该目录，并创建 `index.js`编写组件界面：

```jsx
import Icon from '@/components/Icon'
import { Modal } from 'antd-mobile'
import { useState } from 'react'
import styles from './index.module.scss'

/**
 * 举报反馈菜单
 */
const FeedbackActionMenu = () => {
  
  // 举报类型：normal 不感兴趣或拉黑作者 | junk 垃圾内容
  const [type, setType] = useState('normal')

  // 关闭弹框时的事件监听函数
  const onClose = () => {
  }

  return (
    <div className={styles.root}>
      <Modal
        className="more-action-modal"
        title=""
        transparent
        maskClosable
        footer={[]}
        onClose={onClose}
      >
        <div className="more-action">
          {/* normal 类型时的菜单内容 */}
          {type === 'normal' && (
            <>
              <div className="action-item">
                <Icon type="iconicon_unenjoy1" /> 不感兴趣
              </div>
              <div className="action-item" onClick={() => setType('junk')}>
                <Icon type="iconicon_feedback1" />
                <span className="text">反馈垃圾内容</span>
                <Icon type="iconbtn_right" />
              </div>
              <div className="action-item">
                <Icon type="iconicon_blacklist" /> 拉黑作者
              </div>
            </>
          )}

          {/* junk 类型时的菜单内容 */}
          {type === 'junk' && (
            <>
              <div className="action-item" onClick={() => setType('normal')}>
                <Icon type="iconfanhui" />
                <span className="back-text">反馈垃圾内容</span>
              </div>
              <div className="action-item">旧闻重复</div>
              <div className="action-item">广告软文</div>
              <div className="action-item">内容不实</div>
              <div className="action-item">涉嫌违法</div>
              <div className="action-item">
                <span className="text">其他问题</span>
                <Icon type="iconbtn_right" />
              </div>
            </>
          )}
        </div>
      </Modal>
    </div>
  )
}

export default FeedbackActionMenu
```



2. 在首页组件中引入以上弹出菜单组件：

```jsx
import FeedbackActionMenu from './components/FeedbackActionMenu'
```

```jsx
{/* 举报反馈弹出菜单 */}
<FeedbackActionMenu />
```



3. 在 `store/reducers/home.js`中，编写反馈弹出菜单相关的 Reducer 逻辑：

```js
// 初始状态
const initialState = {
  // ...
  feedbackAction: {
    // 控制弹出菜单的显示隐藏
    visible: false,
    // 当前反馈的目标文章ID
    articleId: 0
  }
}

export const home = (state = initialState, action) => {
  const { type, payload } = action

  switch (type) {
    case 'home/feedback_action':
      return {
        ...state,
        feedbackAction: payload
      }

      // ...
  }
}
```



4. 在`store/actions/home.js`中，编写 Action Creator：

```js
/**
 * 设置举报反馈菜单信息
 */
export const setFeedbackAction = ({ visible, feedbackId }) => ({
  type: 'home/feedback_action',
  payload: {
    visible,
    articleId
  }
})
```



5. 在文章列表项组件 `ArticleItem` 中编写扩展功能：点击右下角的 `x` 按钮后能执行组件传入的回调函数

先为组件添加一个 onClose 属性：

```jsx
const ArticleItem = ({
	// ...
  onClose
}) => {
  // ...
}
```

再添加 x 按钮的点击事件：

```jsx
{/* 只有登录用户可以举报反馈 */}
{hasToken() && (
  <span className="close" onClick={e => {
      // 防止事件穿透
      e.stopPropagation()
      // 调用传入的回调函数，并将当前文章ID作为参数传出
      onClose(articleId)
    }}>
    <Icon type="iconbtn_essay_close" />
  </span>
)}
```



6. 在文章列表组件`ArticleList` 中，为文章列表项组件 `ArticleItem` 设置 `onClose` 回调函数，并在该回调函数中调用 Action 去改变弹出菜单的相关状态值：

```jsx
import { useDispatch } from 'react-redux'
import { setFeedbackAction } from '@/store/actions/home'
```

```jsx
const onArticleItemFeedback = (articleId) => {
    dispatch(setFeedbackAction({
      articleId,
      visible: true
    }))
  }
```

```jsx
<ArticleItem
  // ...
  onClose={onArticleItemFeedback}
  />
```



7. 在弹出菜单 `FeedbackActionMenu` 组件中，从 Redux 中获取相关状态来控制显示与隐藏：

```jsx
// 弹框的状态
const feedbackAction = useSelector(state => state.home.feedbackAction)

const dispatch = useDispatch()

// 关闭弹框时的事件监听函数
const onClose = () => {
  // 更新弹出菜单的状态
  dispatch(setFeedbackAction({
    visible: false,
    articleId: 0
  }))
}
```



---



## 文章展示：上拉加载

> 目标：实现用户在上拉文章列表，触达页面底部时，去加载下一页的文章数据



实现思路：

- 利用 `react-window` 和 `react-window-infinite-loader` 组件实现该功能



**操作步骤**

1. 安装依赖包

```bash
npm i react-window react-window-infinite-loader --save
```



2. 在 `ArticleList` 组件代码中，使用 `react-window-infinite-loader` 创建拥有上拉加载功能的虚拟列表：

```jsx
import InfiniteLoader from 'react-window-infinite-loader'
```

```jsx
<div className={styles.root}>
  <div className="articles">
    {/* 支持上拉加载的虚拟列表组件 */}
    <InfiniteLoader
      isItemLoaded={isItemLoaded}
      itemCount={itemCount}
      loadMoreItems={loadMoreItems}
      >
      
    </InfiniteLoader>
  </div>
</div>
```



3. 实现以上 `InfiniteLoader` 组件需要传入的属性：

```jsx
// 标记是否还有更多数据可供加载
const [hasMore, setHasMore] = useState(true)


// 判定整个列表是否加载完成的条件
const isItemLoaded = index => {
  return !hasMore || index < articles.items.length
}


// 当前列表项数量（当有下一页数据可加载时，只需要将其设置为当前文章数据条数 + 1 即可）
const itemCount = hasMore ? articles.items.length + 1 : articles.items.length


// 请求加载下一页的数据
const loadMoreItems = async () => {
  // 如果列表数据为空说明当前 tab 还没被激活过，此时无需加载数据
  if (articles.items.length === 0) return

  // 请求加载下一页数据
  const { results, pre_timestamp } = await loadArticleListData(channelId, articles.preTimestamp)

  // 将请求到的数据和之前的数据合并
  setArticles({
    items: [...articles.items, ...results],
    preTimestamp: pre_timestamp
  })

  // 如果返回的 pre_timestamp 无值，则表示已加载到最后一页数据了
  if (!pre_timestamp) {
    setHasMore(false)
  }
}
```



4. 为 `InfiniteLoader` 设置子元素 `VariableSizeList` 组件

> VariableSizeList 组件是支持每个列表项高度不同的虚拟列表。

```jsx
<InfiniteLoader
  // ...
  >
  {({ onItemsRendered, ref }) => {
    return (
      <VariableSizeList
        height={(window.innerHeight - 90) * (window.innerWidth / 375)}
        itemCount={itemCount}
        itemSize={getItemSize}
        onItemsRendered={onItemsRendered}
        // 传给每个列表项的数据
        itemData={{
          items: articles.items,
          hasMore
        }}
        ref={list => {
          if (list) {
            ref(list)
            listRef.current = list
          }
        }}
        >
				
      </VariableSizeList>
    )
  }}
</InfiniteLoader>
```



5. 实现 `VariableSizeList` 组件所需的属性

```jsx
// 对 VariableSizeList 的引用
const listRef = useRef()

// 用来存储每个列表项的高度
const sizeMap = useRef({})

// 用来往 sizeMap 中记录每个列表项的高度
const setItemSize = (index, size) => {
  if (sizeMap.current[index]) return
  sizeMap.current = { ...sizeMap.current, [index]: size }
  listRef.current.resetAfterIndex(index)
}

// 从 sizeMap 中获取每个列表项的高度
const getItemSize = index => {
  return sizeMap.current[index] || 70
}
```



6. 在 `ArticleList` 代码文件中，新建一个组件 `ArticleItemWrapper`

> 该组件是对每个列表项内容的封装，主要是为了方便计算每个列表项的高度、及后续添加骨架屏效果。

```jsx
/**
 * 文章列表项包装组件，便于计算每个列表项的高度、及骨架屏效果的设置
 * @param {Object} props.style 行内样式
 * @param {Object} props.data 业务数据
 * @param {Number} props.index 列表项当前索引
 * @param {Function} props.setItemSize 记录当前列表项高度的函数
 */
const ArticleItemWrapper = ({ style, data, index, setItemSize }) => {
  const dispatch = useDispatch()
  const history = useHistory()
  const rowRef = useRef()
  const article = data.items[index]

  // 将当前列表项的 DOM 元素高度记录下来
  useEffect(() => {
    if (rowRef.current) {
      setItemSize(index, rowRef.current.scrollHeight)
    }
  }, [rowRef, index, setItemSize])

  // 点击当前列表项后跳转到文章详情页
  const onToAritcleDetail = () => {
    history.push(`/article/${article.art_id}`)
  }

  // 打开举报反馈菜单
  const onArticleItemFeedback = articleId => {
    dispatch(setFeedbackAction({
      articleId,
      visible: true
    }))
  }

  // 没有文章数据时，显示占位信息
  if (!article) {
    return (
      <div>正在加载中...</div>
    )
  }

  // 有文章数据时，显示文章列表项
  return (
    <div className="article-item" style={style} ref={rowRef} onClick={onToAritcleDetail}>
      {/* 列表项主体内容 */}
      <ArticleItem
        articleId={article.art_id}
        coverType={article.cover.type}
        coverImages={article.cover.images}
        title={article.title}
        authorName={article.aut_name}
        commentCount={article.comm_count}
        publishDate={article.pubdate}
        onClose={onArticleItemFeedback}
      />

      {/* 当没有更多文章数据时，在最后一个列表项中显示 ”没有更多文章了“ 的提示信息 */}
      {!data.hasMore && index === data.items.length - 1 && (
        <div className="list-no-more">没有更多文章了</div>
      )}
    </div>
  )
}
```



7. 在 `ArticleList` 组件中，为 `VariableSizeList` 组件设置子元素：

```jsx
<VariableSizeList
	// ...
  >
  {props => <ArticleItemWrapper {...props} setItemSize={setItemSize} />}
</VariableSizeList>
```



效果：

<img src="极客园移动端2.assets/image-20210908161313124.png" alt="image-20210908161313124" style="zoom:40%;" />

<img src="极客园移动端2.assets/image-20210908161456448.png" alt="image-20210908161456448" style="zoom:40%;" />



---



## 文章展示：骨架屏

> 目标：将之前实现的 `ArticleItemWrapper` 中的 ”正在加载中...“ 字样，实现成骨架屏形式



<img src="极客园移动端2.assets/image-20210908161810326.png" alt="image-20210908161810326" style="zoom:40%;" />



实现思路：

我们主要借助 `react-content-loader` 组件来实现骨架屏效果。



**操作步骤**

1. 安装依赖包

```bash
npm i react-content-loader --save
```



2. 在 `ArticleItemWrapper` 组件中使用 `ContentLoader` 绘制骨架屏，替换原先的”正在加载中...“

```jsx
import ContentLoader from 'react-content-loader'
```

```jsx
// 没有文章数据时，显示占位信息
if (!article) {
  return (
    <ContentLoader
      speed={2}
      width={375}
      height={137}
      viewBox="0 0 375 137"
      backgroundColor="#f3f3f3"
      foregroundColor="#ecebeb"
      >
      {/* SVG 图形 */}
      <rect x="16" y="15" rx="3" ry="3" width="223" height="22" />
      <rect x="245" y="14" rx="3" ry="3" width="110" height="80" />
      <rect x="16" y="105" rx="0" ry="0" width="50" height="22" />
      <rect x="76" y="105" rx="0" ry="0" width="50" height="22" />
      <rect x="136" y="105" rx="0" ry="0" width="50" height="22" />
    </ContentLoader>
  )
}
```



---



## 文章展示：下拉刷新

> 目标：实现文章列表的下拉刷新功能



<img src="极客园移动端2.assets/image-20210908162901932.png" alt="image-20210908162901932" style="zoom:40%;" />

实现思路：

我们借助 antd-mobile 的 `PullToRefresh` 组件实现该功能。



**操作步骤**

1. 在 `ArticleList` 组件代码中，使用 `PullToRefresh` 组件将原先的文章列表包裹起来：

```jsx
import { PullToRefresh } from 'antd-mobile'
```

```jsx
<PullToRefresh
  damping={60}
  refreshing={refreshing}
  onRefresh={onPullToRefresh}
  >
  <div className="articles">
		{/* ... */}
  </div>
</PullToRefresh>
```



2. 创建以上组件属性 `refreshing` 和 `onRefresh`对应的内容：

```jsx
// 代表是否正处于下拉刷新中（其实就是节流阀）
const [refreshing, setRefreshing] = useState(false)

// 下拉刷新
const onPullToRefresh = async () => {
  setRefreshing(true)

  // 请求获取最新的数据
  const { results, pre_timestamp } = await loadArticleListData(channelId, Date.now())
  setArticles({
    items: results,
    preTimestamp: pre_timestamp
  })

  // 再主动预加载下一页的数据
  loadMoreItems()

  setRefreshing(false)
}
```



---



# 文章搜索



## 文章搜索页的静态结构

> 目标：实现文章搜索页面的主要静态结构和样式



首页入口：

<img src="极客园移动端2.assets/image-20210908165325226.png" alt="image-20210908165325226" style="zoom:40%;" />

搜索页面：

<img src="极客园移动端2.assets/image-20210908165359419.png" alt="image-20210908165359419" style="zoom:40%;" />

**操作步骤**

1. 为首页 Tab 栏右边的 ”放大镜“ 按钮添加点击事件，点击后跳转到搜索页：

```jsx
import { useHistory } from 'react-router'
```

```jsx
const history = useHistory()
```

```jsx
<Icon type="iconbtn_search" onClick={() => history.push('/search')} />
```



2. 在 `pages/Search/index.js` 中编写页面的静态结构：

```jsx
import Icon from '@/components/Icon'
import NavBar from '@/components/NavBar'
import classnames from 'classnames'
import { useHistory } from 'react-router'
import styles from './index.module.scss'

const Search = () => {
  const history = useHistory()

  return (
    <div className={styles.root}>
      {/* 顶部导航栏 */}
      <NavBar
        className="navbar"
        onLeftClick={() => history.go(-1)}
        rightContent={
          <span className="search-text">搜索</span>
        }
      >
        <div className="navbar-search">
          <Icon type="iconbtn_search" className="icon-search" />

          <div className="input-wrapper">
            {/* 输入框 */}
            <input type="text" placeholder="请输入关键字搜索" />

            {/* 清空输入框按钮 */}
            <Icon type="iconbtn_tag_close" className="icon-close" />
          </div>
        </div>
      </NavBar>

      {/* 搜索历史 */}
      <div className="history" style={{ display: 'block' }}>
        <div className="history-header">
          <span>搜索历史</span>
          <span>
            <Icon type="iconbtn_del" />清除全部
          </span>
        </div>

        <div className="history-list">
          <span className="history-item">
            Python生成九宫格图片<span className="divider"></span>
          </span>
          <span className="history-item">
            Python<span className="divider"></span>
          </span>
          <span className="history-item">
            CSS<span className="divider"></span>
          </span>
          <span className="history-item">
            数据分析<span className="divider"></span>
          </span>
        </div>
      </div>

      {/* 搜素建议结果列表 */}
      <div className={classnames('search-result', 'show')}>
        <div className="result-item">
          <Icon className="icon-search" type="iconbtn_search" />
          <div className="result-value">
            <span>{'高亮'}</span>{`其余`}
          </div>
        </div>
      </div>
    </div>
  )
}

export default Search
```



## 搜索关键字的输入与防抖处理

> 目标：从文本输入框获取输入的关键字内容，且运用防抖机制降低获取频繁



实现思路：

- 防抖实现步骤：
  - 1）清理之前的定时器 
  - 2）新建定时器执行任务



**操作步骤**

1. 声明一个用于存放关键字的状态

```jsx
import { useState } from 'react'
```

```jsx
// 搜索关键字内容
const [keyword, setKeyword] = useState('')
```



2. 为输入框设置 `value` 属性和 `onChange` 事件

```jsx
<input
  type="text"
  placeholder="请输入关键字搜索"
  value={keyword}
  onChange={onKeywordChange}
  />
```

```jsx
const onKeywordChange = e => {
  const text = e.target.value.trim()
  setKeyword(text)
  console.log(text)
}
```



当前效果：每次键盘敲击都会打印出输入框中的内容

<img src="极客园移动端2.assets/image-20210908173010205.png" alt="image-20210908173010205" style="zoom:40%;" />



3. 防抖处理

```jsx
import { useRef } from 'react'
```

```jsx
// 存储防抖定时器
const timerRef = useRef(-1)

const onKeywordChange = e => {
  const text = e.target.value.trim()
  setKeyword(text)

  // 清除之前的定时器
  clearTimeout(timerRef.current)

  // 新建任务定时器
  timerRef.current = setTimeout(() => {
    console.log(text)
  }, 500)
}

// 销毁组件时记得最好要清理定时器
useEffect(() => {
  return () => {
    clearTimeout(timerRef.current)
  }
}, [])
```



---



## 发送请求获取搜索建议数据

> 目标：将输入的关键发送到服务端，获取和该关键字匹配的建议数据



实现思路：

- 通过 Redux Action 来发送请求，获取结果数据后保存在 Redux Store 中



**操作步骤**

1. 创建 `store/reducer/search.js`，编写 Reducer 函数

```jsx
const initialState = {
  suggestions: [],
}

export const search = (state = initialState, action) => {
  const { type, payload } = action

  switch (type) {
    case 'search/suggestions':
      return {
        ...state,
        suggestions: payload
      }

    default:
      return state
  }
}
```



2. 在 `store/index.js`中配置新建的 reducer

```js
// ...
import { search } from './search'

const rootReducer = combineReducers({
  // ...
  search
})
```



3. 创建 `store/actions/search.js`，编写 Action Creator：

```js
import http from '@/utils/http'

/**
 * 设置建议结果到 Redux 中
 * @param {Array} list 建议结果
 */
const setSuggestions = list => {
  return {
    type: 'search/suggestions',
    payload: list
  }
}

/**
 * 获取输入联想建议列表
 * @param {string} q 查询内容
 * @returns thunk
 */
export const getSuggestions = keyword => {
  return async dispatch => {
    // 请求建议结果
    const res = await http.get('/suggestion', {
      params: {
        q: keyword
      }
    })
    const { options } = res.data.data

    // 转换结果：将每一项建议拆分成关键字匹配的高亮部分和非高亮部分
    const list = options.map(item => {
      const rest = item.substr(keyword.length)
      return { keyword, rest }
    })

    // 保存到 Redux 中
    dispatch(setSuggestions(list))
  }
}
```



4. 在之前的防抖定时器中调用 Action：

```jsx
import { getSuggestions } from '@/store/actions/search'
```

```jsx
const dispatch = useDispatch()

// 代表是否正处于搜索操作中
const [isSearching, setIsSearching] = useState(false)

const onKeywordChange = e => {
  const text = e.target.value.trim()
  setKeyword(text)

  // 清除之前的定时器
  clearTimeout(timerRef.current)

  // 新建任务定时器
  timerRef.current = setTimeout(() => {
    // 仅当输入的关键字不为空时，执行搜索
    if (text) {
      setIsSearching(true)
      dispatch(getSuggestions(text))
    } else {
      setIsSearching(false)
    }
  }, 500)
}
```



---



## 搜索建议结果列表的渲染

> 目标：从 Redux 中获取搜索建议数据，渲染到界面上



实现思路：

- 使用 `useSelector`从 Redux 中获取数据



**操作步骤**

1. 从 Redux 中获取搜索建议数据

```jsx
import { getSuggestions } from '@/store/actions/search'
```

```jsx
const suggestions = useSelector(state => state.search.suggestions)
```



2. 将搜索建议数据渲染到界面上

```jsx
<div className={classnames('search-result', 'show')}>
  {suggestions.map((item, index) => {
    return (
      <div className="result-item" key={index}>
        <Icon className="icon-search" type="iconbtn_search" />
        <div className="result-value">
          <span>{item.keyword}</span> {item.rest}
        </div>
      </div>
    )
  })}
</div>
```



效果：

<img src="极客园移动端2.assets/image-20210908184810879.png" alt="image-20210908184810879" style="zoom:40%;" />



---



## 搜索建议列表和搜索历史的按需显示

> 目标：实现在做搜索操作时只显示搜索建议列表；其他情况只显示搜索历史



<img src="极客园移动端2.assets/image-20210908185453822.png" alt="image-20210908185453822" style="zoom:40%;" />



实现思路：

- 利用之前创建的 `isSearching` 状态，控制建议列表和搜索历史的显示、隐藏



**操作步骤**

1. 

```jsx
{/* 搜索历史 */}
<div className="history" style={{ display: isSearching ? 'none' : 'block' }}>

</div>

{/* 搜素建议结果列表 */}
<div className={classnames('search-result', isSearching ? 'show' : false)}>
  
</div>
```



---



## 清空输入框关键字的按钮

> 目标：点击输入框内的 x 按钮，清空输入的关键字内容



<img src="极客园移动端2.assets/image-20210908185607593.png" alt="image-20210908185607593" style="zoom:40%;" />



实现思路：

- 清空输入框绑定的状态
- 清空 Redux 中保存的搜索建议结果



**操作步骤**

1. 在 `store/reducers/search.js`中添加清空搜索建议数据的 Reducer 逻辑

```jsx
export const search = (state = initialState, action) => {
  const { type, payload } = action

  switch (type) {
    case 'search/clear':
      return {
        ...state,
        suggestions: []
      }
      
    // ...
  }
}
```



2. 在 `store/actions/search.js`中编写 Action Creator：

```js
/**
 * 清空搜索建议
 * @returns thunk
 */
export const clearSuggestions = () => {
  return {
    type: 'search/clear'
  }
}
```



3. 为输入框内的 x 按钮添加点击事件

```jsx
{/* 清空输入框按钮，且在输入内容时才显示 */}
{keyword && (
  <Icon type="iconbtn_tag_close" className="icon-close" onClick={onClear} />
)}
```

```jsx
// 清空
const onClear = () => {
  // 清空输入框内容
  setKeyword('')

  // 设置为非搜索状态
  setIsSearching(false)

  // 清空Redux中的搜索建议数据
  dispatch(clearSuggestions())
}
```



----



## 动态渲染搜索历史记录

> 目标：将每次输入的搜索关键字记录下来，再动态渲染到界面上



实现思路：

- 在成功搜索后，将关键字存入 Redux 和 LocalStorage 中
- 从 Redux 中获取所有关键字，并渲染到界面



**操作步骤**

1. 在 `store/reducers/search.js`中，添加操作搜索历史相关的 Reducer 逻辑：

```js
const initialState = {
	// ...
  histories: []
}

export const search = (state = initialState, action) => {
  const { type, payload } = action

  switch (type) {
    case 'search/add_history':
      return {
        ...state,
        histories: [payload, ...state.histories]
      }
      
    // ...
  }
}
```



2. 在`utils/storage.js`中，添加在本地缓存中操作搜索历史相关的工具函数：

```js
// 搜索关键字的本地缓存键名
const SEARCH_HIS_KEY = 'itcast_history_k'

/**
 * 从缓存获取搜索历史关键字
 */
export const getLocalHistories = () => {
  return JSON.parse(localStorage.getItem(SEARCH_HIS_KEY)) || []
}

/**
 * 将搜索历史关键字存入本地缓存
 * @param {Array} histories 
 */
export const setLocalHistories = histories => {
  localStorage.setItem(SEARCH_HIS_KEY, JSON.stringify(histories))
}

/**
 * 删除本地缓存中的搜索历史关键字
 */
export const removeLocalHistories = () => {
  localStorage.removeItem(SEARCH_HIS_KEY)
}
```



3. 在 `store/actions/search.js`中，修改原先请求搜索建议的 Action Creator：

```js
export const getSuggestions = keyword => {
  return async (dispatch, getState) => {
    // ...

    // 搜索成功后，保存为历史关键字
    // 1）保存搜索关键字到 Redux 中
    await dispatch(addSearchHistory(keyword))
    // 2）保存搜索关键字到 LocalStorage 中
    const { histories } = getState().search
    setLocalHistories(histories)
  }
}
```



4. 在 `store/index.js`中，添加从本地缓存初始化搜索历史的逻辑：

```js
import { getLocalHistories, getTokenInfo } from '@/utils/storage'

const store = createStore(
  // ...

  // 参数二：初始化时要加载的状态
  {
		// ...
    
    search: {
      histories: getLocalHistories(),
      suggestions: []
    }
  },

  // ...
)
```



5. 在搜索页面中，从 Redux 获取搜索历史数据，再渲染到界面

```js
const histories = useSelector(state => state.search.histories)
```

```jsx
<div className="history-list">
  {histories.map((item, index) => {
    return (
      <span className="history-item" key={index}>
        {item}<span className="divider"></span>
      </span>
    )
  })}
</div>
```



效果：

<img src="极客园移动端2.assets/image-20210909094945398.png" alt="image-20210909094945398" style="zoom:40%;" />



---



## 搜索历史记录的去重

> 目标：当前搜索历史中会存储重复的关键字，我们要进行去重处理



实现思路：

- 使用  Set 进行自动去重



**操作步骤**

1. 在 `store/reducers/search.js` 中，修改 Reducer 逻辑：

```js
export const search = (state = initialState, action) => {
  const { type, payload } = action

  switch (type) {
    case 'search/add_history':
      // 将历史数组放入 Set 中，就能自动去除重复的关键字
      // 注意：Set 只对基础类型的值有自动去重功能，对象无效
      const set = new Set([payload, ...state.histories])

      // 去重后将 Set 转回数组
      const newArr = Array.from(set)

      return {
        ...state,
        histories: newArr
      }

    // ...
  }
}
```



---



## 搜索历史记录的数量限制

> 目标：将搜索历史中的关键字最大数量限制在 10 个，防止列表太长



实现思路：

- 在完成去重后，判断是否已满 10 个，如果已满则删除最后一个关键字



**操作步骤**

1. 在 `store/reducers/search.js`中，修改 Reducer 逻辑：

```js
export const search = (state = initialState, action) => {
  const { type, payload } = action

  switch (type) {
    case 'search/add_history':
      // 将历史数组放入 Set 中，就能自动去除重复的关键字
      // 注意：Set 只对基础类型的值有自动去重功能，对象无效
      const set = new Set([payload, ...state.histories])

      // 去重后将 Set 转回数组
      const newArr = Array.from(set)

			// 判断是否已满10个，如已满则删除末尾的一个
      if (newArr.length > 10) {
        newArr.pop()
      }
      
      return {
        ...state,
        histories: newArr
      }

    // ...
  }
}
```



---



## 清空搜索历史记录

> 目标：点击”清除全部“按钮后，删除全部的搜索历史记录



<img src="极客园移动端2.assets/image-20210909102100740.png" alt="image-20210909102100740" style="zoom:40%;" />



实现思路：

- 删除 Redux 和 LocalStorage 中存储的历史记录



**操作步骤**

1. 在 `store/reducers/seach.js`中，添加删除搜索历史相关的 Reducer 逻辑

```js
export const search = (state = initialState, action) => {
  const { type, payload } = action

  switch (type) {
    case 'search/clear_histories':
      return {
        ...state,
        histories: []
      }

    // ...
  }
}
```



2. 在 `store/actions/search.js`中，编写 Action Creator：

```js
/**
 * 删除 Redux 中的历史记录
 */
export const doClearHistories = () => {
  return {
    type: 'search/clear_histories'
  }
}

/**
 * 清空搜索历史
 * @returns 
 */
export const clearHistories = () => {
  return dispatch => {
    // 删除 Redux 中的历史记录
    dispatch(doClearHistories())
    
    // 删除 LocalStorage 中的历史记录
    removeLocalHistories()
  }
}
```



3. 在搜索页面中，为 "清除全部" 按钮添加点击事件

```jsx
<span onClick={onClearHistories}>
  <Icon type="iconbtn_del" />清除全部
</span>
```

```jsx
// 清空搜索历史
const onClearHistories = () => {
  dispatch(clearHistories())
}
```



---



## 点击”搜索“或建议结果跳到搜索详情页

> 目标：点击顶部 ”搜索“ 按钮，或点击搜索建议列表中的一项，跳转到搜索详情页



<img src="极客园移动端2.assets/image-20210909103450023.png" alt="image-20210909103450023" style="zoom:40%;" />



**操作步骤**

1. 为元素添加点击事件

> 点击搜索按钮跳转时，携带当前输入的关键字作为参数

```jsx
<span 
  className="search-text" 
  onClick={() => gotoSearchDetail(keyword)}
  >搜索</span>
```

> 点击搜索建议列表项跳转时，携带当前列表项上显示的内容作为参数

```jsx
<div
  className="result-item"
  key={index}
  onClick={() => gotoSearchDetail(item.keyword + item.rest)}
  >
  ...
</div>
```

```jsx
// 跳转到搜索详情页
const gotoSearchDetail = text => {
  if (text) {
    history.push(`/search/result?q=${text}`)
  }
}
```



---



## 搜索详情页的静态结构

> 目标：实现搜索详情页的静态结构和样式



<img src="极客园移动端2.assets/image-20210909105543672.png" alt="image-20210909105543672" style="zoom:40%;" />



**操作步骤**

1. 将资源包中对应的样式文件，拷贝到 `pages/Search/Result/`目录下，然后编写该目录下的`index.js`：

```jsx
import ArticleItem from '@/components/ArticleItem'
import NavBar from '@/components/NavBar'
import { useDispatch } from 'react-redux'
import { useHistory, useLocation } from 'react-router-dom'
import styles from './index.module.scss'

const SearchResult = () => {
  const history = useHistory()
  const location = useLocation()
  const dispatch = useDispatch()

  return (
    <div className={styles.root}>
      {/* 顶部导航栏 */}
      <NavBar onLeftClick={() => history.go(-1)}>搜索结果</NavBar>

      <div className="article-list">
        <div>
          <ArticleItem
            articleId={"111"}
            coverType={0}
            coverImages={[]}
            title={"测试1"}
            authorName={"张三"}
            commentCount={10}
            publishDate={"2010-10-10 19:08:10"}
            onClose={() => { }}
            />
        </div>
        <div>
          <ArticleItem
            articleId={"222"}
            coverType={0}
            coverImages={[]}
            title={"测试2"}
            authorName={"李四"}
            commentCount={66}
            publishDate={"2010-10-10 9:08:10"}
            onClose={() => { }}
            />
        </div>
      </div>
    </div>
  )
}

export default SearchResult
```



---



## 请求搜索详情页数据

> 目标：获取从搜索页面传入的参数后，调用后端接口获取搜索详情



**操作步骤**

1. 获取通过 URL 地址传入到搜索详情页的查询字符串参数 `q`

```js
// 获取通过 URL 地址传入的查询字符串参数
const params = new URLSearchParams(location.search)
const q = params.get('q')
```



2. 在 `store/reducers/search.js` 中添加保存搜索详情数据的 Reducer 逻辑

```js
const initialState = {
  // ...
  searchResults: []
}

export const search = (state = initialState, action) => {
  const { type, payload } = action

  switch (type) {
    case 'search/results':
      return {
        ...state,
        searchResults: payload
      }

    // ...
  }
}
```



3. 在 `store/actions/search.js`中编写 Action Creator：

```jsx
/**
 *  设置搜索详情到 Redux 中
 * @param {Array} results 
 * @returns 
 */
export const setSearchResults = results => {
  return {
    type: 'search/results',
    payload: results
  }
}

/**
 * 获取搜索文章列表
 * @param {string} q 查询内容
 * @returns thunk
 */
export const getSearchResults = q => {
  return async dispatch => {
    const res = await http.get('/search', {
      params: { q }
    })

    // 保存结果数据到 Redux 中
    dispatch(setSearchResults(res.data.data))
  }
}
```



4. 在搜索详情页面中，通过 `useEffect` 在进入页面时调用以上编写的 Action：

```js
import { getSearchResults } from '@/store/actions/search'
import { useEffect } from 'react'
```

```jsx
useEffect(() => {
  dispatch(getSearchResults(q))
}, [q, dispatch])
```



---



## 渲染搜索详情列表

> 目标：将请求到的搜索详情数据渲染到界面上



**操作步骤**

1. 从 Redux 中获取搜索详情数据

```js
import { useDispatch, useSelector } from 'react-redux'
```

```js
const articles = useSelector(state => state.search.searchResults)
```



2. 将数据渲染成列表

```jsx
<div className="article-list">
  {articles?.results?.map(article => {
    return (
      <div key={article.art_id}>
        <ArticleItem
          articleId={article.art_id}
          coverType={article.cover.type}
          coverImages={article.cover.images}
          title={article.title}
          authorName={article.aut_name}
          commentCount={article.comm_count}
          publishDate={article.pubdate}
          onClose={() => { }}
          />
      </div>
    )
  })}
</div>
```



---

## 点击搜索详情列表跳到文章详情页

> 目标：实现在搜索详情列表中点击一个列表项，跳转到文章的详情页面



**操作步骤**

1. 为搜索详情列表项添加点击事件

```jsx
<div key={article.art_id} onClick={() => gotoAritcleDetail(article.art_id)}>
  // ...
</div>
```

```jsx
// 跳转到文章详情页面
const gotoAritcleDetail = articleId => {
  history.push(`/article/${articleId}`)
}
```



---



# 文章详情页



## 文章详情页面的静态结构



## 获取文章详情数据



## 渲染文章详情



## 关注



## 点赞



## 评论



---



# 功能优化



## KeepAlive 缓存



## 滚动条位置记忆



# 性能优化



## 函数组件的性能优化：React.memo



---



# 打包上线



## 利用 CDN 减少打包后的代码大小